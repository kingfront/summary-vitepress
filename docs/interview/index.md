## 零散知识总结

### js

1. 什么是闭包？

Node 官方说法：
在 js 中，实现外部作用域访问内部作用域中变量的方法叫做“闭包”。
个人总结：
为了避免变量参数重名、或者被篡改，通常会把一些变量放到一个函数作用域内部，然后外部作用域通过函数等其它方式访问内部作用域的变量，所以就形成了闭包。

```js
;(function (bi) {
  var test = 123
  make = function () {
    return test
  }
})()
console.log(make())
```

2. js 的垃圾回收(GC)

`原理：找出不再继续使用的变量，然后释放掉其占用的内存`

- 标记清除法（Mark-Sweep）

此算法分为 标记 和 清除 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁

- 引用计数法（Reference Counting）
  随着引用的次数，进行增减，当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存

V8 对 GC 的优化
分代式垃圾回收
V8 内部将堆内存分为新生代和老生代两块区域，采用不同的策略管理垃圾回收。新生代的对象为存活时间比较短的对象（1-8m），老生代对象为存活时间比较长或常驻内存的对象。

分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率

3. 了解的设计模式

- 发布订阅模式

在 js 中事件模型就相当于传统的发布订阅模式
应用场景：addEventListener 监听事件

- 策略模式

定义： 定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。

- 观察者模式

观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式。

应用场景：Promise 原理

4. 说说浏览器和 node 中的事件循环（EventLoop）

- Node

  当 Node.js 启动后，它会初始化事件循环，处理已提供的输入脚本（或丢入 REPL，本文不涉及到），它可能会调用一些异步的 API、调度定时器，或者调用 process.nextTick()，然后开始处理事件循环
  ┌───────────────────────────┐
  ┌─>│ timers │
  │ └─────────────┬─────────────┘
  │ ┌─────────────┴─────────────┐
  │ │ pending callbacks │
  │ └─────────────┬─────────────┘
  │ ┌─────────────┴─────────────┐
  │ │ idle, prepare │
  │ └─────────────┬─────────────┘ ┌───────────────┐
  │ ┌─────────────┴─────────────┐ │ incoming: │
  │ │ poll │<─────┤ connections, │
  │ └─────────────┬─────────────┘ │ data, etc. │
  │ ┌─────────────┴─────────────┐ └───────────────┘
  │ │ check │
  │ └─────────────┬─────────────┘
  │ ┌─────────────┴─────────────┐
  └──┤ close callbacks │
  └───────────────────────────┘

- 浏览器 js

事件循环分为：宏任务与微任务

1. 宏任务（macrotask）：script（整体代码）、setTimeout/setInterval、I/O、UI rendering 等
2. 微任务（microtask）：Promise、MutationObserver 等

JS 执行过程中，是先执行一个宏任务，再执行这个宏任务产生的对应微任务，执行完毕后，再执行后面的宏任务，以此往复

5. http2.0

- 新的二进制格式（Binary Format）
- 多路复用（MultiPlexing
- header 压缩
- 服务端推送（server push），同 SPDY 一样，HTTP2.0 也具有 server push 功能。

HTTP2.0 的升级改造
前文说了 HTTP2.0 其实可以支持非 HTTPS 的，但是现在主流的浏览器像 chrome，firefox 表示还是只支持基于 TLS 部署的 HTTP2.0 协议，所以要想升级成 HTTP2.0 还是先升级 HTTPS 为好。

当你的网站已经升级 HTTPS 之后，那么升级 HTTP2.0 就简单很多，如果你使用 NGINX，只要在配置文件中启动相应的协议就可以了
使用了，NGINX 会自动向下兼容的。

6. 浏览器缓存机制

- 强缓存
  Exprires、Cache-Control

- 协商缓存
  If-None-Match 、If-Modified-Since

- 缓存位置
  memory-cache、disk-cache、service worker
